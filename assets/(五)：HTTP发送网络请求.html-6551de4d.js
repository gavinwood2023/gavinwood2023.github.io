const t=JSON.parse('{"key":"v-2c872464","path":"/blog/Godot_v4.2.1/%E5%AE%9E%E8%B7%B5%E7%AF%87/(%E4%BA%94)%EF%BC%9AHTTP%E5%8F%91%E9%80%81%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82.html","title":"(五)：HTTP发送网络请求","lang":"zh-CN","frontmatter":{"title":"(五)：HTTP发送网络请求","order":5,"icon":"pen-to-square","category":["Godot"],"article":true,"dir":{"index":true,"order":5},"description":"需求 1、实现HTTP发送网络请求 2、支持GET/POST 实现 1、客户端Godot，HttpUtils.gd 设置为单例自动加载 extends Node # Some headers var headers = [ \\t\\"User-Agent: Pirulo/1.0 (Godot)\\", \\t\\"Accept: */*\\", \\t\\"Content-Type: application/json\\", ] #var content_json = \\"Content-Type: application/json\\" #var content_bytestream = \\"Content-Type: bytestream\\" #var content_text = \\"Content-Type: text/plain\\" #headers.append(content_text) func request(host, url, type=\\"GET\\", body=\\"\\", port=- 1, callback_class=null, callback_method=\\"\\") -&gt; void: \\tvar err = 0 \\tvar http = HTTPClient.new() # Create the Client. \\terr = http.connect_to_host(host, port) \\tassert(err == OK) # Make sure connection is OK. \\t \\t# Wait until resolved and connected. \\twhile http.get_status() == HTTPClient.STATUS_CONNECTING or http.get_status() == HTTPClient.STATUS_RESOLVING: \\t\\thttp.poll() \\t\\t#print(\\"Connecting...\\") \\t\\tif not OS.has_feature(\\"web\\"): \\t\\t\\tOS.delay_msec(5) \\t\\telse: \\t\\t\\tawait Engine.get_main_loop() \\t\\t\\t \\tassert(http.get_status() == HTTPClient.STATUS_CONNECTED) \\tif type == \\"GET\\": \\t\\terr = http.request(HTTPClient.METHOD_GET, url, headers, body) \\telif type == \\"POST\\": \\t\\terr = http.request(HTTPClient.METHOD_POST, url, headers, body) \\t\\t \\tassert(err == OK) # Make sure all is OK. \\t \\twhile http.get_status() == HTTPClient.STATUS_REQUESTING: \\t\\t# Keep polling for as long as the request is being processed. \\t\\thttp.poll() \\t\\t#print(\\"Requesting...\\") \\t\\tif OS.has_feature(\\"web\\"): \\t\\t\\t# Synchronous HTTP requests are not supported on the web, \\t\\t\\t# so wait for the next main loop iteration. \\t\\t\\tawait Engine.get_main_loop() \\t\\t\\tpass \\t\\telse: \\t\\t\\tOS.delay_msec(5) \\t\\t\\t \\tassert(http.get_status() == HTTPClient.STATUS_BODY or http.get_status() == HTTPClient.STATUS_CONNECTED) # Make sure request finished well. \\tif http.has_response(): \\t\\t# If there is a response... \\t\\t \\t\\t#headers = http.get_response_headers_as_dictionary() # Get response headers. \\t\\t#print(\\"code: \\", http.get_response_code()) # Show response code. \\t\\t#print(\\"**headers:\\\\\\\\n\\", headers) # Show headers. \\t\\t## Getting the HTTP Body \\t\\t#if http.is_response_chunked(): \\t\\t\\t## Does it use chunks? \\t\\t\\t#print(\\"Response is Chunked!\\") \\t\\t#else: \\t\\t\\t## Or just plain Content-Length \\t\\t\\t#var bl = http.get_response_body_length() \\t\\t\\t#print(\\"Response Length: \\", bl) \\t\\t# This method works for both anyway \\t\\tvar rb = PackedByteArray() # Array that will hold the data. \\t\\t \\t\\twhile http.get_status() == HTTPClient.STATUS_BODY: \\t\\t\\t# While there is body left to be read \\t\\t\\thttp.poll() \\t\\t\\t# Get a chunk. \\t\\t\\tvar chunk = http.read_response_body_chunk() \\t\\t\\tif chunk.size() == 0: \\t\\t\\t\\tif not OS.has_feature(\\"web\\"): \\t\\t\\t\\t\\t# Got nothing, wait for buffers to fill a bit. \\t\\t\\t\\t\\tOS.delay_usec(10) \\t\\t\\t\\telse: \\t\\t\\t\\t\\tawait Engine.get_main_loop() \\t\\t\\telse: \\t\\t\\t\\trb = rb + chunk # Append to read buffer. \\t\\t \\t\\tvar text = rb.get_string_from_utf8() \\t\\tif callback_class != null and callback_method != null and callback_method.length() &gt; 0: \\t\\t\\tcallback_class.call_deferred(callback_method, text)","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/Godot_v4.2.1/%E5%AE%9E%E8%B7%B5%E7%AF%87/(%E4%BA%94)%EF%BC%9AHTTP%E5%8F%91%E9%80%81%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82.html"}],["meta",{"property":"og:site_name","content":"乐见分享"}],["meta",{"property":"og:title","content":"(五)：HTTP发送网络请求"}],["meta",{"property":"og:description","content":"需求 1、实现HTTP发送网络请求 2、支持GET/POST 实现 1、客户端Godot，HttpUtils.gd 设置为单例自动加载 extends Node # Some headers var headers = [ \\t\\"User-Agent: Pirulo/1.0 (Godot)\\", \\t\\"Accept: */*\\", \\t\\"Content-Type: application/json\\", ] #var content_json = \\"Content-Type: application/json\\" #var content_bytestream = \\"Content-Type: bytestream\\" #var content_text = \\"Content-Type: text/plain\\" #headers.append(content_text) func request(host, url, type=\\"GET\\", body=\\"\\", port=- 1, callback_class=null, callback_method=\\"\\") -&gt; void: \\tvar err = 0 \\tvar http = HTTPClient.new() # Create the Client. \\terr = http.connect_to_host(host, port) \\tassert(err == OK) # Make sure connection is OK. \\t \\t# Wait until resolved and connected. \\twhile http.get_status() == HTTPClient.STATUS_CONNECTING or http.get_status() == HTTPClient.STATUS_RESOLVING: \\t\\thttp.poll() \\t\\t#print(\\"Connecting...\\") \\t\\tif not OS.has_feature(\\"web\\"): \\t\\t\\tOS.delay_msec(5) \\t\\telse: \\t\\t\\tawait Engine.get_main_loop() \\t\\t\\t \\tassert(http.get_status() == HTTPClient.STATUS_CONNECTED) \\tif type == \\"GET\\": \\t\\terr = http.request(HTTPClient.METHOD_GET, url, headers, body) \\telif type == \\"POST\\": \\t\\terr = http.request(HTTPClient.METHOD_POST, url, headers, body) \\t\\t \\tassert(err == OK) # Make sure all is OK. \\t \\twhile http.get_status() == HTTPClient.STATUS_REQUESTING: \\t\\t# Keep polling for as long as the request is being processed. \\t\\thttp.poll() \\t\\t#print(\\"Requesting...\\") \\t\\tif OS.has_feature(\\"web\\"): \\t\\t\\t# Synchronous HTTP requests are not supported on the web, \\t\\t\\t# so wait for the next main loop iteration. \\t\\t\\tawait Engine.get_main_loop() \\t\\t\\tpass \\t\\telse: \\t\\t\\tOS.delay_msec(5) \\t\\t\\t \\tassert(http.get_status() == HTTPClient.STATUS_BODY or http.get_status() == HTTPClient.STATUS_CONNECTED) # Make sure request finished well. \\tif http.has_response(): \\t\\t# If there is a response... \\t\\t \\t\\t#headers = http.get_response_headers_as_dictionary() # Get response headers. \\t\\t#print(\\"code: \\", http.get_response_code()) # Show response code. \\t\\t#print(\\"**headers:\\\\\\\\n\\", headers) # Show headers. \\t\\t## Getting the HTTP Body \\t\\t#if http.is_response_chunked(): \\t\\t\\t## Does it use chunks? \\t\\t\\t#print(\\"Response is Chunked!\\") \\t\\t#else: \\t\\t\\t## Or just plain Content-Length \\t\\t\\t#var bl = http.get_response_body_length() \\t\\t\\t#print(\\"Response Length: \\", bl) \\t\\t# This method works for both anyway \\t\\tvar rb = PackedByteArray() # Array that will hold the data. \\t\\t \\t\\twhile http.get_status() == HTTPClient.STATUS_BODY: \\t\\t\\t# While there is body left to be read \\t\\t\\thttp.poll() \\t\\t\\t# Get a chunk. \\t\\t\\tvar chunk = http.read_response_body_chunk() \\t\\t\\tif chunk.size() == 0: \\t\\t\\t\\tif not OS.has_feature(\\"web\\"): \\t\\t\\t\\t\\t# Got nothing, wait for buffers to fill a bit. \\t\\t\\t\\t\\tOS.delay_usec(10) \\t\\t\\t\\telse: \\t\\t\\t\\t\\tawait Engine.get_main_loop() \\t\\t\\telse: \\t\\t\\t\\trb = rb + chunk # Append to read buffer. \\t\\t \\t\\tvar text = rb.get_string_from_utf8() \\t\\tif callback_class != null and callback_method != null and callback_method.length() &gt; 0: \\t\\t\\tcallback_class.call_deferred(callback_method, text)"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-17T14:11:38.000Z"}],["meta",{"property":"article:author","content":"GavinWood"}],["meta",{"property":"article:modified_time","content":"2024-08-17T14:11:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"(五)：HTTP发送网络请求\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-08-17T14:11:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"GavinWood\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[],"git":{"createdTime":1723903898000,"updatedTime":1723903898000,"contributors":[{"name":"nick","email":"1175924232@qq.com","commits":1}]},"readingTime":{"minutes":2.08,"words":623},"filePathRelative":"blog/Godot_v4.2.1/实践篇/(五)：HTTP发送网络请求.md","localizedDate":"2024年8月17日","excerpt":"<h4> 需求</h4>\\n<p>1、实现HTTP发送网络请求<br>\\n2、支持GET/POST</p>\\n<h4> 实现</h4>\\n<p>1、客户端Godot，<a href=\\"http://HttpUtils.gd\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">HttpUtils.gd</a> 设置为单例自动加载</p>\\n<div class=\\"language-text line-numbers-mode\\" data-ext=\\"text\\"><pre class=\\"language-text\\"><code>extends Node\\n\\n# Some headers\\nvar headers = [\\n\\t\\"User-Agent: Pirulo/1.0 (Godot)\\",\\n\\t\\"Accept: */*\\",\\n\\t\\"Content-Type: application/json\\",\\n]\\n#var content_json = \\"Content-Type: application/json\\"\\n#var content_bytestream = \\"Content-Type: bytestream\\"\\n#var content_text = \\"Content-Type: text/plain\\"\\n#headers.append(content_text)\\n\\n\\nfunc request(host, url, type=\\"GET\\", body=\\"\\", port=- 1, callback_class=null, callback_method=\\"\\") -&gt; void:\\n\\tvar err = 0\\n\\tvar http = HTTPClient.new() # Create the Client.\\n\\terr = http.connect_to_host(host, port)\\n\\tassert(err == OK) # Make sure connection is OK.\\n\\t\\n\\t# Wait until resolved and connected.\\n\\twhile http.get_status() == HTTPClient.STATUS_CONNECTING or http.get_status() == HTTPClient.STATUS_RESOLVING:\\n\\t\\thttp.poll()\\n\\t\\t#print(\\"Connecting...\\")\\n\\t\\tif not OS.has_feature(\\"web\\"):\\n\\t\\t\\tOS.delay_msec(5)\\n\\t\\telse:\\n\\t\\t\\tawait Engine.get_main_loop()\\n\\t\\t\\t\\n\\tassert(http.get_status() == HTTPClient.STATUS_CONNECTED)\\n\\n\\tif type == \\"GET\\":\\n\\t\\terr = http.request(HTTPClient.METHOD_GET, url, headers, body)\\n\\telif type == \\"POST\\":\\n\\t\\terr = http.request(HTTPClient.METHOD_POST, url, headers, body)\\n\\t\\t\\n\\tassert(err == OK) # Make sure all is OK.\\n\\t\\n\\twhile http.get_status() == HTTPClient.STATUS_REQUESTING:\\n\\t\\t# Keep polling for as long as the request is being processed.\\n\\t\\thttp.poll()\\n\\t\\t#print(\\"Requesting...\\")\\n\\t\\tif OS.has_feature(\\"web\\"):\\n\\t\\t\\t# Synchronous HTTP requests are not supported on the web,\\n\\t\\t\\t# so wait for the next main loop iteration.\\n\\t\\t\\tawait Engine.get_main_loop()\\n\\t\\t\\tpass\\n\\t\\telse:\\n\\t\\t\\tOS.delay_msec(5)\\n\\t\\t\\t\\n\\tassert(http.get_status() == HTTPClient.STATUS_BODY or http.get_status() == HTTPClient.STATUS_CONNECTED) # Make sure request finished well.\\n\\n\\tif http.has_response():\\n\\t\\t# If there is a response...\\n\\t\\t\\n\\t\\t#headers = http.get_response_headers_as_dictionary() # Get response headers.\\n\\t\\t#print(\\"code: \\", http.get_response_code()) # Show response code.\\n\\t\\t#print(\\"**headers:\\\\\\\\n\\", headers) # Show headers.\\n\\n\\t\\t## Getting the HTTP Body\\n\\t\\t#if http.is_response_chunked():\\n\\t\\t\\t## Does it use chunks?\\n\\t\\t\\t#print(\\"Response is Chunked!\\")\\n\\t\\t#else:\\n\\t\\t\\t## Or just plain Content-Length\\n\\t\\t\\t#var bl = http.get_response_body_length()\\n\\t\\t\\t#print(\\"Response Length: \\", bl)\\n\\n\\t\\t# This method works for both anyway\\n\\t\\tvar rb = PackedByteArray() # Array that will hold the data.\\n\\t\\t\\n\\t\\twhile http.get_status() == HTTPClient.STATUS_BODY:\\n\\t\\t\\t# While there is body left to be read\\n\\t\\t\\thttp.poll()\\n\\t\\t\\t# Get a chunk.\\n\\t\\t\\tvar chunk = http.read_response_body_chunk()\\n\\t\\t\\tif chunk.size() == 0:\\n\\t\\t\\t\\tif not OS.has_feature(\\"web\\"):\\n\\t\\t\\t\\t\\t# Got nothing, wait for buffers to fill a bit.\\n\\t\\t\\t\\t\\tOS.delay_usec(10)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tawait Engine.get_main_loop()\\n\\t\\t\\telse:\\n\\t\\t\\t\\trb = rb + chunk # Append to read buffer.\\n\\t\\t\\n\\t\\tvar text = rb.get_string_from_utf8()\\n\\t\\tif callback_class != null and callback_method != null and callback_method.length() &gt; 0:\\n\\t\\t\\tcallback_class.call_deferred(callback_method, text)\\n\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{t as data};
